#pragma config(Sensor, in1,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    PotHand,        sensorPotentiometer)
#pragma config(Sensor, in7,    GyroBot7,       sensorGyro)
#pragma config(Sensor, in8,    GyroTop8,       sensorGyro)
#pragma config(Sensor, dgtl1,  frontSonic,     sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftSonic,     sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  puncherLED,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  puncherStop,    sensorTouch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightSonic,     sensorSONAR_inch)
#pragma config(Motor,  port1,           rightFrontMotor1, tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,           leftFrontMotor2A, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           frontWheelLift3BY, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rollerIn4,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rollerUp5,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intakeBottomMotor6, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           capFlipperMotor7, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           puncherMotor8CY, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftRearMotor9D, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port10,          rightRearMotor10, tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

  int score_mode=0;
  int timeDrop=0;
  void go_auto();
  int minTurn = 20;
	int state6U = 0;
	int state6D =0;
	int Inches2encoder=27;
	int turnDiameter=17;
	float leftTravel,rightTravel, diff;
	int Lencode,Rencode;
	void move2D(int motorPower, int turnPower);
	void DisplayData();
	void moveForwardDistanceInch(float distance_Left, float distance_Right,int power);
	void moveTurnRightDegree(int turnDegree,int power);
	void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power);
	void moveRollers();
	int Roller_InPower=0;
	int Roller_InPowerLevelMax=100;
	int Roller_InPowerLevel=Roller_InPowerLevelMax;
	int Roller_UpPower=0;
	int Roller_UpPowerLevelMax=100;
	int Roller_UpPowerLevel=Roller_UpPowerLevelMax;
	int Btn6D_pressed=0;
	int Btn6U_pressed=0;
	int PunchState=0;  // S=1, P=0
	int PunchPower=0;
	int PunchPowerMax=30;
	int PunchPowerHold=5;
	bool PunchTriggerred=false;
	bool PunchTriggerAuto=false;
	bool PunchTriggerReady=false;
	int PunchShotStop=0;
	task PunchStateMachine();
	task LCDLEDStateMachine();
	int GyroTop=0;
	int GyroBot=0;
	float GyroBalance=1.3;
	float Gyro_Cali=-0.5/1.10;
	int GyroAngle=0;




/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	score_mode=-1;
	go_auto();
}

void go_auto()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	clearTimer(T1);
		if (score_mode==0) return;
	timeDrop=time1[T1];
	return;
}





/*---------111111111111111------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
  clearLCDLine(0);                  	// Clear line 1 (0) of the LCD
  clearLCDLine(1);                  	// Clear line 2 (1) of the LCD
  bLCDBacklight = true;             	// Turn on LCD Backlight
	clearTimer(T1);
	score_mode=-1;

	startTask(PunchStateMachine);
	startTask(LCDLEDStateMachine);
	while(true)
	{


		DisplayData();
		int verticalPower = vexRT[Ch3]; // get joystick value for right vertical channel
		int horizontalPower = vexRT[Ch4]; // get joystick value for left vertical channel

		move2D(verticalPower, horizontalPower);
		moveRollers();

	if (vexRT[Btn6D]==1)
  		{
  		Btn6D_pressed=1;
  		//Roller_InPowerLevel*= -1;  // + In, - out
  		Roller_InPower=	Roller_InPowerLevel;
  		turnLEDOn(puncherLED);
			}
			else     //6D ==0
			{
				if (Btn6D_pressed==1)  Roller_InPowerLevel*= -1;  // + in, - Out
				Btn6D_pressed=0;
			}

	if (vexRT[Btn6U]==1)
  		{
  		Btn6U_pressed=1;
  		Roller_UpPower=	Roller_UpPowerLevel;
  		if (Roller_UpPower==0)
  				{
  					Roller_InPower=0;
  					Roller_InPowerLevel	= Roller_InPowerLevelMax;
  					turnLEDOff(puncherLED);
  				}
			}
			else     //6U ==0
			{
				if (Btn6U_pressed==1)
					{
						Roller_UpPowerLevel=Roller_UpPowerLevelMax-Roller_UpPower;
					}
				Btn6U_pressed=0;
			}

/*
		if (stop){
				if(vexRT[Btn5D]) {
				puncherPower = 40;
			}

			if(vexRT[Btn5U]) {
				puncherPower = -40;
			}

			if(SensorValue[puncherStop]==0){stop = false;
				wait1Msec(50);}
		}
		else{
			if(SensorValue[puncherStop] == 1){puncherPower = 0; stop = true;}
			else if(vexRT[Btn5D]){puncherPower = 40;}
			else if(vexRT[Btn5U]) {
				puncherPower = -40;
			}
		}

		motor[puncherMotor8CY] = puncherPower;
		*/

		move2D(verticalPower, horizontalPower);
		moveRollers();
	}
}

	void move2D(int motorPower, int turnPower){
		    if (abs(turnPower) > minTurn) {
        turnPower -= abs(turnPower)/turnPower *minTurn;
    }
    else turnPower = 0;

    int leftPower = motorPower + turnPower;
    int rightPower = motorPower - turnPower;
    if (abs(leftPower)> 100){
        leftPower = 100*(leftPower/abs(leftPower));
    }
    if (abs(rightPower) > 100) {
        rightPower = 100*(rightPower/abs(rightPower));
    }

    motor[rightFrontMotor1] = rightPower;
    motor[rightRearMotor10] = rightPower;
    motor[leftFrontMotor2A] = leftPower;
    motor[leftRearMotor9D] = leftPower;

	}

void moveRollers()
{
	motor[rollerIn4]=Roller_InPower;
	motor[rollerUp5]=Roller_UpPower;
	motor[intakeBottomMotor6]=Roller_UpPower;
}

task LCDLEDStateMachine()
	{
		DisplayData();
	}
	;

/*
	void DisplayData()
{
	if ((score_mode)>=0)  // <0 score mode shows data
	{
 		displayLCDString(0, 0, "Auto Selected: ");
		if (score_mode==0) displayLCDString(1, 0, "score: No Autonomus ");
		if (score_mode==1) displayLCDString(1, 0, "score: Red Front   ");
		if (score_mode==2) displayLCDString(1, 0, "score: Blue Front   ");
		if (score_mode==3) displayLCDString(1, 0, "score: Red Back    ");
		if (score_mode==4) displayLCDString(1, 0, "score: Blue Back ");
		return;
	}
	else{
		int b1, b2;
		b1 = nImmediateBatteryLevel;
//		b2 = SensorValue[Expander]/0.28
		displayLCDString(0,0,"Battery1: ");
		displayNextLCDNumber(b1);
	//	displayLCDString(1,0,"Battery2: ");
	//	displayNextLCDNumber(b2);
 	//	displayLCDString(1, 0, "Run Time: ");
 	//	displayNextLCDNumber(time1[T1]/10);
		displayLCDString(1, 0, "puncherStop: ");
 		displayNextLCDNumber(SensorValue[puncherStop]);
 	}
}
*/
void DisplayData()
{
	score_mode=-1;
	if ((score_mode)>=0)  // <0 score mode shows data
	{
 		displayLCDString(0, 0, "Auto Selected: ");
		if (score_mode==0) displayLCDString(1, 0, "score: No Autonomus ");
		if (score_mode==1) displayLCDString(1, 0, "score: Red Front   ");
		if (score_mode==2) displayLCDString(1, 0, "score: Blue Front   ");
		if (score_mode==3) displayLCDString(1, 0, "score: Red Back    ");
		if (score_mode==4) displayLCDString(1, 0, "score: Blue Back ");
		return;
	}
	else{
		GyroTop=SensorValue[GyroTop8]*GyroBalance;
		GyroBot=SensorValue[GyroBot7];
		GyroAngle=(GyroTop-GyroBot)*Gyro_Cali;
 		displayLCDString(0, 0, "GT:");
 		displayNextLCDNumber(GyroTop);
 		displayNextLCDString(",GB:");
 		displayNextLCDNumber(GyroBot);
 //		displayNextLCDString(":Diff= ");

// 		displayLCDString(1,0,"Run Time:diff ");
 		displayLCDString(1,0,"diff ");
		displayNextLCDNumber(GyroAngle);
  		displayNextLCDString("  ");
		//displayNextLCDNumber(time1[T1]/10);
 		//displayNextLCDNumber(SensorValue(Potent));//[T1]/10);
 	}
}


void moveForward(int forwardsPower, int turnClockPower)
{
 int power=forwardsPower-turnClockPower;
 motor[rightFrontMotor1] = power;
 motor[rightRearMotor10] = power;
 power=forwardsPower+turnClockPower;
 motor[leftFrontMotor2A] = power;
 motor[leftRearMotor9D] = power;
}


void moveForwardDistanceInch(float distance_Left, float distance_Right,int power)
{
	float left2right_ratio=distance_Left/distance_Right;
	move2D(power,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	while (true)
	{
//		Lencode=fabs(nMotorEncoder[leftMotor]);
//		Rencode=fabs(nMotorEncoder[rightMotor]);//*101/63;
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=leftTravel-rightTravel*left2right_ratio;
		if (fabs(leftTravel)>distance_Left)	break;
		if (fabs(rightTravel)>distance_Right)	break;
//		moveForward(power,-diff*power/fabs(power+0.001));
		moveForward(power,0);
	}
  move2D(0,0);
}

void moveTurnRightDegree(int turnDegree,int power)
{
	float turnDistance=3.14*turnDiameter*turnDegree/360;
	moveTurnRightDistanceInch(turnDistance, turnDistance,power);
}

void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power)
{
		moveForward(0,power);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */

  while (true)
	{

		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=abs(Lencode)-abs(Rencode);
		if (abs(leftTravel)>abs(distance_Left))	break;
		if (abs(rightTravel)>abs(distance_Right))	break;
//		moveForward(diff*power/fabs(power+0.001),power);
		moveForward(diff*power/fabs(power+0.001),power);
	}
  move2D(0,0);
}

void movePunch()
{
	motor[puncherMotor8CY]=PunchPower;  // controled by Punch State machine
}

task PunchStateMachine()
	{
	 	// punch move								status
	 	//  A,					S=1, P=0, 	Init=0,  5D to power
		//	B,					S=1, p!=0  			1,  triggered S,start to engage
		// 	C, 					S=0, P!=0, 			2,  release S,
		//  D, (Delay)	S=0, P=P_hold, 	3, Hold engaged
		//	E,					S=0, p!=0, 			4,		5D to Fire
		//  when fired, goto B (1)
		//
		while(true)
		{
			PunchShotStop=SensorValue[puncherStop];
			if (vexRT(Btn5D)==1) PunchTriggerred=true;
		switch (PunchState)
			{
				case 0: // intit, S=undefined, P=0
					PunchTriggerReady=false;
					PunchPower=PunchPowerMax;
					if( PunchShotStop)
					{
						PunchPower=0;  //stop at init position
						PunchState++;
					}
			// stay in init position, if no trigger not ready
					break;
				case 1: //s=1
					PunchTriggerReady=false;
					if (PunchTriggerred||PunchTriggerAuto)
							PunchPower=PunchPowerMax; // power up to hold position
					if (PunchShotStop==0) PunchState++; //Power continue until S=0
					break;
				case	2:
					wait1Msec(3000);		//S=0
					PunchPower=PunchPowerHold;  //hold the punch, S=0
					PunchTriggerAuto=false; // clear any trigger
					PunchTriggerred=false;
					PunchState++;
					break;
			case 3:

					if (PunchTriggerred||PunchTriggerAuto) // 5d or auto trigger
					{
					PunchPower=PunchPowerMax; //fire
					PunchTriggerAuto=false; //reset trigger
					PunchTriggerred=false;
					} else
					{
					PunchTriggerReady=true;
					}
					//else wait for shot
					if (PunchShotStop==1) PunchState=1; //return to 1
					break;
				default: break;
			}
			wait1Msec(10);
			movePunch();
	}
}
