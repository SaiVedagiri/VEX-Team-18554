#pragma config(Sensor, in1,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    PotHand,        sensorPotentiometer)
#pragma config(Sensor, in6,    Expander,       sensorAnalog)
#pragma config(Sensor, in7,    GyroBot7,       sensorGyro)
#pragma config(Sensor, in8,    GyroTop8,       sensorGyro)
#pragma config(Sensor, dgtl1,  frontSonic,     sensorSONAR_mm)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorNone)
#pragma config(Sensor, dgtl5,  leftSonic,      sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  puncherLED,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  puncherStop,    sensorTouch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightSonic,     sensorSONAR_mm)
#pragma config(Motor,  port1,           rightFrontMotor1, tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           leftFrontMotor2A, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           frontWheelLift3BY, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rollerIn4,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rollerUp5,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intakeBottomMotor6, tmotorNone, openLoop)
#pragma config(Motor,  port7,           capFlipperMotor7, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           puncherMotor8CY, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftRearMotor9D, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port10,          rightRearMotor10, tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

  int score_mode=0;
  bool RedColor=true;
  int timeDrop=0;
  void go_auto();
  int minTurn = 20;
	int state6U = 0;
	int state6D =0;
	int Inches2encoder=22;
	int turnDiameter=17;
	float leftTravel,rightTravel, diff;
	int Lencode,Rencode;
	task PunchStateMachine();
	task displayTask();
	void move2D(int motorPower, int turnPower);
	void DisplayData();
	void moveForwardDistanceMM(float distance,int power);
	void moveForwardDistanceInch(float distance_Left, float distance_Right,int power);
	void moveTurnRightDegree(int turnDegree,int power);
	void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power);
	void moveRollers();
	void moveWallUntilSonarMM(int Gyro_line, int wall_distance, int Front_distance,int power);
	int Roller_InPower=0;
	int Roller_InPowerLevelMax=100;
	int Roller_InPowerLevel=Roller_InPowerLevelMax;
	int Roller_UpPower=0;
	int Roller_UpPowerLevelMax=100;
	int Roller_UpPowerLevel=Roller_UpPowerLevelMax;
	int Btn5U_pressed=0;
	int Btn6D_pressed=0;
	int Btn6U_pressed=0;
	int PunchState=0;  // S=1, P=0
	int PunchPower=0;
	int PunchPowerMax=100;
	int PunchPowerHold=10;
	bool PunchTriggerred=false;
	bool PunchTriggerAuto=false;
	bool PunchTriggerReady=false;
	int PunchShotStop=0;
	int GyroTop=0;
	int GyroBot=0;
	float GyroBalance=1.3;
	float Gyro_Cali=-0.5/1.10;
	int GyroAngle=0;
	int MoveFaceForward=1;
	int FrontSonar_mm=0;
	int RightSonar_mm=0;
	int LeftSonar_mm=0;
	int HighFlag_mm=500;
	int MiddleFlag_mm=300;
	int Left_Encoder = 0;
	int Right_Encoder = 0;




/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	score_mode=-1;
	go_auto();
}

task displayTask()
{
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
while(true)
{
	DisplayData();
	wait1Msec(20);
}
}

void go_auto()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
/*
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
*/
	clearTimer(T1);

	//PunchTriggerAuto=true;
	motor[rollerIn4]=Roller_InPower;
	motor[rollerUp5]=Roller_UpPower;
	moveForwardDistanceMM(35*25.4, 50);

	timeDrop=time1[T1];

	return;
}


/*---------111111111111111------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
/*  clearLCDLine(0);                  	// Clear line 1 (0) of the LCD
  clearLCDLine(1);                  	// Clear line 2 (1) of the LCD
  bLCDBacklight = true;             	// Turn on LCD Backlight
*/
	clearTimer(T1);
	SensorType(GyroTop8) = sensorNone;
	SensorType(GyroBot7) = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[GyroTop8] =sensorGyro; // sensorGyro;
	SensorType[GyroBot7] =sensorGyro; // sensorGyro;
	SensorValue[GyroBot7]=0;
	SensorValue[GyroTop8]=0;
	score_mode=-2;
	MoveFaceForward=1;
	startTask(PunchStateMachine);
	startTask (displayTask);
	wait1Msec(10000);
	go_auto();
//	return;
	while(true)
	{
		int verticalPower = vexRT[Ch3]; // get joystick value for right vertical channel
		int horizontalPower = vexRT[Ch4]; // get joystick value for left vertical channel

	if (vexRT[Btn6D]==1)
  		{
  		Btn6D_pressed=1;
  		Roller_InPower=	Roller_InPowerLevel;
  		turnLEDOn(puncherLED);
			}
			else     //6D ==0
			{
				if (Btn6D_pressed==1)  Roller_InPowerLevel*= -1;  // + in, - Out
				Btn6D_pressed=0;
			}

	if (vexRT[Btn6U]==1)
  		{
  		Btn6U_pressed=1;
  		Roller_UpPower=	Roller_UpPowerLevel;
  		if (Roller_UpPower==0)
  				{
  					Roller_InPower=0;
  					Roller_InPowerLevel	= Roller_InPowerLevelMax;
  					turnLEDOff(puncherLED);
  				}
			}
			else     //6U ==0
			{
				if (Btn6U_pressed==1)
					{
						Roller_UpPowerLevel=Roller_UpPowerLevelMax-Roller_UpPower;
					}
				Btn6U_pressed=0;
			}

	if (vexRT[Btn5U]==1)
  		{
  		Btn5U_pressed=1;
 			}
			else     //5D ==0
			{
				if (Btn5U_pressed==1)  MoveFaceForward*= -1;  // + in, - Out
				Btn5U_pressed=0;
			}

		move2D(verticalPower*MoveFaceForward, horizontalPower);
		moveRollers();
		DisplayData();
	}
}

void move2D(int motorPower, int turnPower){
		    if (abs(turnPower) > minTurn) {
        turnPower -= abs(turnPower)/turnPower *minTurn;
    }
    else turnPower = 0;

    int leftPower = motorPower + turnPower;
    int rightPower = motorPower - turnPower;
    if (abs(leftPower)> 100){
        leftPower = 100*(leftPower/abs(leftPower));
    }
    if (abs(rightPower) > 100) {
        rightPower = 100*(rightPower/abs(rightPower));
    }

    motor[rightFrontMotor1] = rightPower;
    motor[rightRearMotor10] = rightPower;
    motor[leftFrontMotor2A] = leftPower;
    motor[leftRearMotor9D] = leftPower;

	}

void moveRollers()
{
	motor[rollerIn4]=Roller_InPower;
	motor[rollerUp5]=Roller_UpPower;
	motor[intakeBottomMotor6]=Roller_UpPower;
}

void DisplayData()
{
		int b1,b2, tmp;
		// two Gyros and Angle
		GyroTop=SensorValue[GyroTop8]*GyroBalance;
		GyroBot=SensorValue[GyroBot7];
		GyroAngle=(GyroBot)*1;//Gyro_Cali;
		// two batteries
		b1=nImmediateBatteryLevel;
		b2=SensorValue[Expander]/0.280;
		// three sonar
		FrontSonar_mm=SensorValue[frontSonic];
		RightSonar_mm=SensorValue[rightSonic];
		LeftSonar_mm=SensorValue[leftSonic];
		Left_Encoder = SensorValue[leftEncoder];
		Right_Encoder = SensorValue[rightEncoder];
		//SensorValue(sonarSensor);
		// LCD Display
	switch (score_mode) {
		case 0:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: No Autonomus ");
						break;
		case 1:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: Red Front ");
						break;
		case 2:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: Blue Front ");
						break;
		case 3:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: Red Far ");
						break;
		case 4:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: Blue Far ");
						break;
		case -1:
 						displayLCDString(0, 0, "GT:");
 						displayNextLCDNumber(GyroTop);
 						displayNextLCDString(",GB:");
 						displayNextLCDNumber(GyroBot);
 						displayLCDString(1,0,"Angle= ");
						displayNextLCDNumber(GyroAngle);
  					displayNextLCDString("   ");
 						break;
		case -2:
	//					displayLCDString(0, 0, "B1=");
	//					displayNextLCDNumber(b1);
						displayLCDString(0, 0, "EL=");
						displayNextLCDNumber(Left_Encoder);
						displayNextLCDString("ER=");
						displayNextLCDNumber(Right_Encoder);
//						displayNextLCDString(" :B2=");
//						displayNextLCDNumber(b2);
						displayNextLCDString(" G=");
						displayNextLCDNumber(GyroAngle);
						displayNextLCDString("  ");
//						displayNextLCDNumber(time1[T1]);
						displayLCDString(1, 0, "F");
						displayNextLCDNumber(FrontSonar_mm);
						displayNextLCDString(" R");
						displayNextLCDNumber(RightSonar_mm);
						displayNextLCDString( " L");
						displayNextLCDNumber(LeftSonar_mm);
						displayNextLCDString("  ");
						break;
		default:
						break;
	}
	// LED display
	if (fabs(FrontSonar_mm-HighFlag_mm)<20)
			turnLEDOn(puncherLED);
	else if
			(fabs(FrontSonar_mm-MiddleFlag_mm)<20)
			turnLEDOn(puncherLED);
	else
			turnLEDOff(puncherLED);
}


void moveForward(int forwardsPower, int turnClockPower)
{
 int power=forwardsPower-turnClockPower;
 motor[rightFrontMotor1] = power;
 motor[rightRearMotor10] = power;
 power=forwardsPower+turnClockPower;
 motor[leftFrontMotor2A] = power;
 motor[leftRearMotor9D] = power;
}


void moveForwardDistanceMM(float distance,int power)
{
	move2D(power,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	int GyroAngle0=GyroAngle;

  while (true)
	{
//		Lencode=fabs(nMotorEncoder[leftMotor]);
//		Rencode=fabs(nMotorEncoder[rightMotor]);//*101/63;
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;

		diff=GyroAngle-GyroAngle0;
//		if (fabs(leftTravel*25.4)>distance_Left)	break;
		if (fabs(rightTravel*25.4)>distance)	break;
//		moveForward(power,-diff*power/fabs(power+0.001));
		moveForward(power,-2*diff);
	}
  move2D(0,0);
}

void moveForwardDistanceInch(float distance_Left, float distance_Right,int power)
{
	float left2right_ratio=distance_Left/distance_Right;
	move2D(power,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	while (true)
	{
//		Lencode=fabs(nMotorEncoder[leftMotor]);
//		Rencode=fabs(nMotorEncoder[rightMotor]);//*101/63;
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=leftTravel-rightTravel*left2right_ratio;
		if (fabs(leftTravel)>distance_Left)	break;
		if (fabs(rightTravel)>distance_Right)	break;
//		moveForward(power,-diff*power/fabs(power+0.001));
		moveForward(power,0);
	}
  move2D(0,0);
}

void moveTurnRightDegree(int turnDegree,int power)
{
	float turnDistance=3.14*turnDiameter*turnDegree/360;
	moveTurnRightDistanceInch(turnDistance, turnDistance,power);
}

void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power)
{
		moveForward(0,power);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */

  while (true)
	{

		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=abs(Lencode)-abs(Rencode);
		if (abs(leftTravel)>abs(distance_Left))	break;
		if (abs(rightTravel)>abs(distance_Right))	break;
//		moveForward(diff*power/fabs(power+0.001),power);
		moveForward(diff*power/fabs(power+0.001),power);
	}
  move2D(0,0);
}

void movePunch()
{
	motor[puncherMotor8CY]=PunchPower;  // controled by Punch State machine
}

void moveWallUntilSonarMM(int Gyro_line, int wall_distance, int Front_distance,int power)
	{
	SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	int Front_Sonar=0;
	int Side_Sonar=0;
	int Front_Gyro=0;
	int Side_diff;
	int Gyro_diff;

  while (true)
	{
		Front_Sonar=FrontSonar_mm;
		if (RedColor)
		Side_Sonar=LeftSonar_mm;
		else
		Side_Sonar=RightSonar_mm;
		Front_Gyro=GyroAngle;

		Side_diff=Side_Sonar-wall_distance; //assume blue
		if (RedColor) Side_diff*=-1;
		motor[leftRearMotor9D]=power+Side_diff;
		motor[rightRearMotor10] = power-Side_diff;

		Gyro_diff=Front_Gyro-Gyro_line;
		motor[leftRearMotor9D]=power-Gyro_diff;
		motor[rightRearMotor10] = power+Gyro_diff;
		if (Front_Sonar<Front_distance)	break;
	}
	move2D(0,0);
	}

task PunchStateMachine()
	{
	 	// punch move								status
	 	//  A,					S=1, P=0, 	Init=0,  5D to power
		//	B,					S=1, p!=0  			1,  triggered S,start to engage
		// 	C, 					S=0, P!=0, 			2,  release S,
		//  D, (Delay)	S=0, P=P_hold, 	3, Hold engaged
		//	E,					S=0, p!=0, 			4,		5D to Fire
		//  when fired, goto B (1)
		//
		while(true)
		{
			PunchShotStop=SensorValue[puncherStop];
			if (vexRT(Btn5D)==1) PunchTriggerred=true;
		switch (PunchState)
			{
				case 0: // intit, S=undefined, P=0
					PunchTriggerReady=false;
					PunchPower=PunchPowerMax;
					if( PunchShotStop)
					{
						PunchPower=0;  //stop at init position
						PunchState++;
					}
			// stay in init position, if no trigger not ready
					break;
				case 1: //s=1
					PunchTriggerReady=false;
					if (PunchTriggerred||PunchTriggerAuto)
							PunchPower=PunchPowerMax; // power up to hold position
					if (PunchShotStop==0) PunchState++; //Power continue until S=0
					break;
				case	2:
					wait1Msec(1300);		//S=0
					PunchPower=PunchPowerHold;  //hold the punch, S=0
					PunchTriggerAuto=false; // clear any trigger
					PunchTriggerred=false;
					PunchState++;
					break;
			case 3:

					if (PunchTriggerred||PunchTriggerAuto) // 5d or auto trigger
					{
					PunchPower=PunchPowerMax; //fire
					PunchTriggerAuto=false; //reset trigger
					PunchTriggerred=false;
					} else
					{
					PunchTriggerReady=true;
					}
					//else wait for shot
					if (PunchShotStop==1) PunchState=1; //return to 1
					break;
				default: break;
			}
			wait1Msec(10);
			movePunch();
	}
}
