#pragma config(Sensor, in1,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    PotHand,        sensorPotentiometer)
#pragma config(Sensor, in6,    Expander,       sensorAnalog)
#pragma config(Sensor, in7,    GyroBot7,       sensorGyro)
#pragma config(Sensor, in8,    GyroTop8,       sensorGyro)
#pragma config(Sensor, dgtl1,  frontSonic,     sensorSONAR_mm)
#pragma config(Sensor, dgtl3,  puncherLED,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  puncherStop,    sensorTouch)
#pragma config(Sensor, dgtl5,  leftSonic,      sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightSonic,     sensorSONAR_mm)
#pragma config(Motor,  port1,           rightFrontMotor1, tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           rightRearMotor2A, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port3,           frontWheelLift3BY, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rollerUp5,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftFrontMotor6, tmotorNone, openLoop)
#pragma config(Motor,  port7,           capFlipperMotor7, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           puncherMotor8CY, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftRearMotor9D, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port10,          rollerIn10,    tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

  int score_mode=0;
  bool RedColor=true;
  int timeDrop=0;
  int minTurn = 20;
  int temp1, temp2, temp3;
	int Inches2encoder=22;
	int turnDiameter=17;
	float leftTravel,rightTravel, diff;
	int Lencode,Rencode;
	task PunchStateMachine();
	task displayTask();
  void go_auto();
	void go_test();
	void move2D(int motorPower, int turnPower);
	void DisplayData();
	void moveForwardDistanceMM(float distance_Left, float distance_Right, int power);
	void moveRollers();
	void moveWallUntilSonarMM(int Gyro_line, int wall_distance, int Front_distance,int power);
	void moveWallForwardDistanceMM(int Gyro_line, int wall_distance, int forward_distance,int power);
	void moveRightDegreeGyro(int rightTurnDegree, int power);
	void moveTurnRightDegree(float degreeRight,int power);
	int Roller_InPower=0;
	int Roller_InPowerLevelMax=100;
	int Roller_InPowerLevel=Roller_InPowerLevelMax;
	int Roller_UpPower=0;
	int Roller_UpPowerLevelMax=100;
	int Roller_UpPowerLevel=Roller_UpPowerLevelMax;
	int Btn5U_pressed=0;
	int Btn6D_pressed=0;
	int Btn6U_pressed=0;
	int Btn7R_pressed=0;
	int Btn7L_pressed=0;
	int PunchState=0;  // S=1, P=0
	int PunchPower=0;
	int PunchPowerMax=100;
	int PunchPowerHold=10;
	bool PunchTriggerred=false;
	bool PunchTriggerAuto=false;
	bool PunchTriggerReady=false;
	int PunchShotStop=0;
	int GyroTop=0;
	int GyroBot=0;
	float GyroBalance=1.3;
	int GyroAngle=0;
	int MoveFaceForward=1;
	int FrontSonar_mm=0;
	int RightSonar_mm=0;
	int LeftSonar_mm=0;
	int HighFlag_mm=1100;
	int MiddleFlag_mm=680;
	int Left_Encoder = 0;
	int Right_Encoder = 0;




/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
if (	score_mode==0) return; // no auto
	go_auto();
}

task displayTask()
{
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
while(true)
{
	DisplayData();
	wait1Msec(20);
}
}

void go_test()
{
		moveTurnRightDegree(180,50);
}

void go_auto()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
/*
	clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
*/
	score_mode=-2;
	int ColorFactor=1;
	if (!RedColor) ColorFactor=-1;
	clearTimer(T1);
	PunchTriggerAuto=true; // engage puncher

	motor[rollerIn10]=Roller_InPowerLevelMax;
	motor[rollerUp5]=Roller_UpPowerLevelMax;

	moveForwardDistanceMM(890,890, 50);// only move forward
	wait1Msec(200);
	temp2=Lencode;
	temp3=Rencode;
	moveForwardDistanceMM(930,930, -80);
//	moveRightDegreeGyro(800, -75*ColorFactor);
	moveTurnRightDegree(95,-80*ColorFactor);
	temp1=GyroAngle;
//	moveWallUntilSonarMM(-900*ColorFactor,  200, MiddleFlag_mm, 60);//approach
	moveForwardDistanceMM(450,450, 60);// break
	PunchTriggerAuto=true; // engge puncher
	waitUntil(PunchShotStop==1);
//	temp2=GyroAngle;
	moveWallUntilSonarMM(-900*ColorFactor,  100, 150, 60);//approach
//	temp3=GyroAngle;
	moveWallUntilSonarMM(-900*ColorFactor,  180, -1*HighFlag_mm, -50);//away
//	moveForwardDistanceMM(10,10, 50);// break
	wait1Msec(2000);
	PunchTriggerAuto=true; // engge puncher
	waitUntil(PunchShotStop==1);
	timeDrop=time1[T1];
//	int Gyro_line=GyroAngle;
//	moveRightDegreeGyro(Gyro_line+900, -80*sgn(Gyro_line+900));
	return;
	timeDrop=time1[T1];
	return;
//		void moveWallForwardDistance(int Gyro_line, int wall_distance, int forward_distance,int power)

}


/*---------111111111111111------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
/*  clearLCDLine(0);                  	// Clear line 1 (0) of the LCD
  clearLCDLine(1);                  	// Clear line 2 (1) of the LCD
  bLCDBacklight = true;             	// Turn on LCD Backlight
*/
	clearTimer(T1);
	startTask(PunchStateMachine);
	startTask (displayTask);
	SensorType(GyroTop8) = sensorNone;
	SensorType(GyroBot7) = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[GyroTop8] =sensorGyro; // sensorGyro;
	SensorType[GyroBot7] =sensorGyro; // sensorGyro;
	SensorValue[GyroBot7]=0;
	SensorValue[GyroTop8]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
//	score_mode=-2;
	MoveFaceForward=1;
	wait1Msec(3000);
//	go_test();
//	return;
//	go_auto();
	//return;
	while(true)
	{
		int verticalPower = vexRT[Ch3]; // get joystick value for right vertical channel
		int horizontalPower = vexRT[Ch4]; // get joystick value for left vertical channel

	if (vexRT[Btn6D]==1)
  		{
  		Btn6D_pressed=1;
  		Roller_InPower=	Roller_InPowerLevel;
  		turnLEDOn(puncherLED);
			}
			else     //6D ==0
			{
				if (Btn6D_pressed==1)  Roller_InPowerLevel*= -1;  // + in, - Out
				Btn6D_pressed=0;
			}
	if (vexRT[Btn7R]==1)
		  {
  		Btn7R_pressed=1;
			}
			else     //7R ==0
			{
				if (Btn7R_pressed==1)  score_mode+=1;
				if (score_mode==1) RedColor=true;
				if (score_mode==2) RedColor=false;
				if (score_mode==3) score_mode=0;
				Btn7R_pressed=0;
			}

		if (vexRT[Btn7L]==1)
  		{
  		Btn7L_pressed=1;
			}
			else     //6U ==0
			{
				if (Btn7L_pressed==1) go_auto();
				Btn6U_pressed=0;
			}

		if (vexRT[Btn6D]==1)
  		{
  		Btn6D_pressed=1;
  		Roller_InPower=	Roller_InPowerLevel;
  		turnLEDOn(puncherLED);
			}
			else     //6D ==0
			{
				if (Btn6D_pressed==1)  Roller_InPowerLevel*= -1;  // + in, - Out
				Btn6D_pressed=0;
			}

	if (vexRT[Btn8U]==1)
	{
		if(FrontSonar_mm < MiddleFlag_mm)
		{
			int middleFlagDistance = MiddleFlag_mm-FrontSonar_mm;
			moveForwardDistanceMM(middleFlagDistance, middleFlagDistance, -80);
		}
		if(FrontSonar_mm > MiddleFlag_mm)
		{
			int middleFlagDistance = FrontSonar_mm-MiddleFlag_mm;
			moveForwardDistanceMM(middleFlagDistance, middleFlagDistance, 80);
		}
	}
	if (vexRT[Btn5U]==1)
  		{
  		Btn5U_pressed=1;
 			}
			else     //5D ==0
			{
				if (Btn5U_pressed==1)  MoveFaceForward*= -1;  // + in, - Out
				Btn5U_pressed=0;
			}

		move2D(verticalPower*MoveFaceForward, horizontalPower);
		moveRollers();
		DisplayData();
	}
}

void move2D(int motorPower, int turnPower){
		    if (abs(turnPower) > minTurn) {
        turnPower -= abs(turnPower)/turnPower *minTurn;
    }
    else turnPower = 0;

    int leftPower = motorPower + turnPower;
    int rightPower = motorPower - turnPower;
    if (abs(leftPower)> 100){
        leftPower = 100*(leftPower/abs(leftPower));
    }
    if (abs(rightPower) > 100) {
        rightPower = 100*(rightPower/abs(rightPower));
    }

    motor[rightFrontMotor1] = rightPower;
    motor[rightRearMotor2A] = rightPower;
    motor[leftFrontMotor6] = leftPower;
    motor[leftRearMotor9D] = leftPower;

	}

void moveRollers()
{
	motor[rollerIn10]=Roller_InPower;
	motor[rollerUp5]=Roller_UpPower;
}

void DisplayData()
{
		int b1,b2;
		// two Gyros and Angle
		GyroTop=SensorValue[GyroTop8]*GyroBalance;
		GyroBot=SensorValue[GyroBot7];
		GyroAngle=(GyroBot)*1;//Gyro_Cali;
		// two batteries
		b1=nImmediateBatteryLevel;
		b2=SensorValue[Expander]/0.280;
		// three sonar
		FrontSonar_mm=SensorValue[frontSonic];
		RightSonar_mm=SensorValue[rightSonic];
		LeftSonar_mm=SensorValue[leftSonic];
		Left_Encoder = SensorValue[leftEncoder];
		Right_Encoder = SensorValue[rightEncoder];
		//SensorValue(sonarSensor);
		PunchShotStop=SensorValue[puncherStop];
		wait1Msec(20);
		// LCD Display
	switch (score_mode) {
		case 0:
				 		displayLCDString(0, 0, "Auto mode ");
						displayLCDString(1, 0, "     No Autonomus   ");
						break;
		case 1:
				 		displayLCDString(0, 0, "Auto mode: ");
						displayLCDString(1, 0, "     Red Front    ");
						break;
		case 2:
				 		displayLCDString(0, 0, "Auto mode: ");
						displayLCDString(1, 0, "     Blue Front    ");
						break;
		case 3:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: Red Far ");
						break;
		case 4:
				 		displayLCDString(0, 0, "Auto Selected: ");
						displayLCDString(1, 0, "score: Blue Far ");
						break;
		case -1:
 						displayLCDString(0, 0, "GT:");
 						displayNextLCDNumber(GyroTop);
 						displayNextLCDString(",GB:");
 						displayNextLCDNumber(GyroBot);
 						displayLCDString(1,0,"Angle= ");
						displayNextLCDNumber(GyroAngle);
  					displayNextLCDString("   ");
 						break;
		case -2:
						displayLCDString(0, 0, "B1=");
						displayNextLCDNumber(b1);
//						displayLCDString(0, 0, "L");
//						displayNextLCDNumber(Left_Encoder);
//						displayNextLCDString("R");
//						displayNextLCDNumber(Right_Encoder);
						displayNextLCDString(" :B2=");
						displayNextLCDNumber(b2);
						displayNextLCDString("G");
						displayNextLCDNumber(GyroAngle);
						displayNextLCDString("  ");
//						displayNextLCDNumber(time1[T1]);
						displayLCDString(1, 0, "F");
						displayNextLCDNumber(FrontSonar_mm);
						displayNextLCDString(" R");
						displayNextLCDNumber(RightSonar_mm);
						displayNextLCDString( " L");
						displayNextLCDNumber(LeftSonar_mm);
						displayNextLCDString("  ");
						break;
		default:
						break;
	}
	// LED display
	if (fabs(FrontSonar_mm-HighFlag_mm)<100)
			turnLEDOn(puncherLED);
	else if
			(fabs(FrontSonar_mm-MiddleFlag_mm)<50)
			turnLEDOn(puncherLED);
	else
			turnLEDOff(puncherLED);
}


void moveForward(int forwardsPower, int turnClockPower)
{
 int power=forwardsPower-turnClockPower;
 motor[rightFrontMotor1] = power;
 motor[rightRearMotor2A] = power;
 power=forwardsPower+turnClockPower;
 motor[leftFrontMotor6] = power;
 motor[leftRearMotor9D] = power;
}


void moveForwardDistanceMM(float distance_Left, float distance_Right, int power)
{
	move2D(power,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	float left2right_ratio=distance_Left/distance_Right;

  while (true)
	{
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		int ddiff=Lencode-Rencode*left2right_ratio;
		diff=-2*ddiff*sgn(power);
		if (fabs((rightTravel+leftTravel)*25.4/2)>(distance_Left+distance_Right)/2)	break;
		moveForward(power, diff);
		}
  move2D(0,0); //stop coast
}

void moveRightDegreeGyro(int rightTurnDegree, int power)
{
		int Gyro_angle0=GyroAngle;
		int Gyro_diff=GyroAngle-Gyro_angle0;

		while(true)
		{
			moveForward(0, power);
			Gyro_diff=GyroAngle-Gyro_angle0;
			if (fabs(Gyro_diff)>fabs(rightTurnDegree)) break;
		}
  move2D(0,0); //stop coast
}

void movePunch()
{
	motor[puncherMotor8CY]=PunchPower;  // controled by Punch State machine
}

void moveWallUntilSonarMM(int Gyro_line, int wall_distance, int Front_distance,int power)
	{
	SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	int Front_Sonar=0;
	int Side_Sonar=0;
	int Front_Gyro=0;
	int Side_diff;
	int Gyro_diff;
	int Front_Sonar_mean=SensorValue[frontSonic];
//	if (Gyro_line==0) Gyro_line=GyroAngle; // keep angle

  while (true)
	{
		Front_Sonar=SensorValue[frontSonic];
		if (RedColor)
		Side_Sonar=SensorValue[leftSonic];
		else
		Side_Sonar=SensorValue[rightSonic];
		Front_Gyro=GyroAngle;

		Side_diff=Side_Sonar-wall_distance; //assume blue
		if (RedColor) Side_diff*=-1;
		motor[leftRearMotor9D]=power+Side_diff*sgn(power);
		motor[rightRearMotor2A] = power-Side_diff*sgn(power);

		Gyro_diff=Front_Gyro-Gyro_line;
		motor[leftFrontMotor6]=power-Gyro_diff;
		motor[rightFrontMotor1] = power+Gyro_diff;
		if (Front_Sonar<100) continue;
		if (Front_Sonar>1300) continue;
		Front_Sonar_mean=(Front_Sonar_mean*3+Front_Sonar)/4;
		if (Front_Sonar_mean*sgn(Front_distance)<Front_distance)	break;
	}
	move2D(0,0);
	}

	//move distance alone the wall
	void moveWallForwardDistanceMM(int Gyro_line, int wall_distance, int forward_distance,int power)
	{
	SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	int Front_Sonar=0;
	int Side_Sonar=0;
	int Front_Gyro=0;
	int Side_diff;
	int Gyro_diff;

  while (true)
	{
		Front_Sonar=FrontSonar_mm;
		if (RedColor)
		Side_Sonar=LeftSonar_mm;
		else
		Side_Sonar=RightSonar_mm;
		Front_Gyro=GyroAngle;

		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;

		Side_diff=Side_Sonar-wall_distance; //assume blue
		if (RedColor) Side_diff*=-1;
		motor[leftRearMotor9D]=power+Side_diff;
		motor[rightRearMotor2A] = power-Side_diff;

		Gyro_diff=Front_Gyro-Gyro_line;
		motor[leftFrontMotor6]=power-Gyro_diff;
		motor[rightFrontMotor1] = power+Gyro_diff;
		if (fabs(rightTravel*25.4)>forward_distance)	break;
	}
	move2D(0,0);
	}

	void moveTurnRightDegree(float degreeRight,int power)
{
	float turnDiameter=16*25.4*180/192;// 16 inches
	float arc_distance=turnDiameter*3.1416*degreeRight/360;
	SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
	SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	float leftTravel_loc,rightTravel_loc;
	while (true)
	{
			Rencode=SensorValue[rightEncoder];
			Lencode=SensorValue[leftEncoder];
			leftTravel_loc=25.4*Lencode/Inches2encoder;
			rightTravel_loc=25.4*Rencode/Inches2encoder;
		diff=abs(rightTravel_loc)-abs(leftTravel_loc);
		if ((abs(leftTravel_loc)+abs(rightTravel_loc))>2*abs(arc_distance))	break;
		//moveForward(diff*sgn(power),power);
		moveForward(0,power);
	}
	move2D(0,0);
}

task PunchStateMachine()
	{
	 	// punch move								status
	 	//  A,					S=1, P=0, 	Init=0,  5D to power
		//	B,					S=1, p!=0  			1,  triggered S,start to engage
		// 	C, 					S=0, P!=0, 			2,  release S,
		//  D, (Delay)	S=0, P=P_hold, 	3, Hold engaged
		//	E,					S=0, p!=0, 			4,		5D to Fire
		//  when fired, goto B (1)
		//
		while(true)
		{
			PunchShotStop=SensorValue[puncherStop];
			if (vexRT(Btn5D)==1) PunchTriggerred=true;
		switch (PunchState)
			{
				case 0: // intit, S=undefined, P=0
					PunchTriggerReady=false;
					PunchPower=PunchPowerMax;
					if( PunchShotStop)
					{
						PunchPower=0;  //stop at init position
						PunchState++;
					}
			// stay in init position, if no trigger not ready
					break;
				case 1: //s=1
					PunchTriggerReady=false;
					if (PunchTriggerred||PunchTriggerAuto)
							PunchPower=PunchPowerMax; // power up to hold position
					if (PunchShotStop==0) PunchState++; //Power continue until S=0
					break;
				case	2:
					wait1Msec(1300);		//S=0
					PunchPower=PunchPowerHold;  //hold the punch, S=0
					PunchTriggerAuto=false; // clear any trigger
					PunchTriggerred=false;
					PunchState++;
					break;
			case 3:

					if (PunchTriggerred||PunchTriggerAuto) // 5d or auto trigger
					{
					PunchPower=PunchPowerMax; //fire
					PunchTriggerAuto=false; //reset trigger
					PunchTriggerred=false;
					} else
					{
					PunchTriggerReady=true;
					}
					//else wait for shot
					if (PunchShotStop==1) PunchState=1; //return to 1
					break;
				default: break;
			}
			wait1Msec(10);
			movePunch();
	}
}
