#pragma config(Sensor, in1,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    PotHand,        sensorPotentiometer)
#pragma config(Sensor, in7,    GyroTop8,       sensorGyro)
#pragma config(Sensor, in8,    GyroBot7,       sensorGyro)
#pragma config(Sensor, dgtl1,  HeadSonic,      sensorSONAR_mm)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  BackSonic,      sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  shotLED,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  shotStop,       sensorTouch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, FrontSonic,     sensorSONAR_mm)
#pragma config(Motor,  port1,           RightFrontMotor1, tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,           LeftFrontMotor2A, tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           FrontWheelLift3BY, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Roller_In4,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Roller_Up5,    tmotorNone, openLoop)
#pragma config(Motor,  port6,           Roller_Up6C,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           CapFliper7,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           ShotMotor8Y,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LeftRearMotor9D, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port10,          RightRearMotor10, tmotorVex393_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

	int Inches2encoder=27;
	int turnDiameter=14;
	float leftTravel,rightTravel, diff;
	int Lencode,Rencode;
	int armLiftAngle;
 	float armCurrentAngle;
	float armTargetAngle;
	int handCloseAngle;
	int turnClock;
  int FrontHoldPower=0;
  int armHoldLightPower=15;
	int touchsensor=2;
  int score_mode=0;//default ed back
	int timeDrop=0;
	int timeCount=0;
	int Roller_InPower=0;
	int Roller_InPowerLevelMax=100;
	int Roller_InPowerLevel=Roller_InPowerLevelMax;
	int Roller_UpPower=0;
	int Roller_UpPowerLevelMax=100;
	int Roller_UpPowerLevel=Roller_UpPowerLevelMax;
	int Btn6D_pressed=0;
	int Btn6U_pressed=0;
	int PunchState=0;  // S=1, P=0
	int PunchPower=0;
	int PunchPowerMax=80;
	int PunchPowerHold=5;
	bool PunchTriggerred=false;
	bool PunchTriggerAuto=false;
	int PunchShotStop=0;
	int GyroTop=0;
	int GyroBot=0;
	float GyroBalance=1.3;
	float Gyro_Cali=-0.5/1.10;
	int GyroAngle=0;
	int colorfactor=1; // red

void move3D(int forwardsPower,int right, int turnClockPower);
void moveForward(int forwardsPower, int turnClockPower);
void moveForwardDistanceInch(float distance_Left, float distance_Right, int power);
void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power);
void moveTurnRightDegree(int turnDegree,int power);
void moveWall2SonarDistanceMM(float velocity, float sideDistance, float moveDistanceMM);
void DisplayData();
void moveForwardFront(int forwardPower, int turnClockPower);
void moveForwardBack(int forwardPower, int turnClockPower);
void moveArmUpDegree(int upDegree, int armPower);
void moveArmDownDegree(int downDegree, int armPower);
void moveIntake(int istart);
void moveRollers();
void movePunch();
void moveUpFront(int FWpower);
void ShotBall();
void go_auto();
void go_test();
void AUTO_Red_Front();
void AUTO_Blue_Front();
void AUTO_Red_Back();
void AUTO_Blue_Back();
task PunchStateMachine();
//void AUTO_score_BLUE_left();

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	//score_mode=3;
	go_auto();
}

void go_auto()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	clearTimer(T1);
//	score_mode=1;
		if (score_mode==1) AUTO_Red_Front();
		if (score_mode==2) AUTO_Blue_Front();
		if (score_mode==3) AUTO_Red_Back();
		if (score_mode==4) AUTO_Blue_Back();
		if (score_mode==0) return;
	timeDrop=time1[T1];
	return;
}

void go_test()
{
	//go straight line for 100 inches
 //moveForwardDistanceInch(80,80, 20);
	moveWall2SonarDistanceMM(60,170, 50);
	PunchPower=PunchPowerMax;
	movePunch();
  //smoveTurnRightDegree(180,-50);
}



/*---------111111111111111------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
  clearLCDLine(0);                  	// Clear line 1 (0) of the LCD
  clearLCDLine(1);                  	// Clear line 2 (1) of the LCD
  bLCDBacklight = true;             	// Turn on LCD Backlight
	clearTimer(T1);
	int forwards;
	SensorType(GyroTop8) = sensorNone;
	SensorType(GyroBot7) = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[GyroTop8] =sensorGyro; // sensorGyro;
	SensorType[GyroBot7] =sensorGyro; // sensorGyro;
	SensorValue[GyroBot7]=0;
	SensorValue[GyroTop8]=0;
//	wait1Msec(2000);
	startTask(PunchStateMachine);  // controls Puch powwer
//  go_test();
  //return;

  while (true)
  {
//		startTask(PunchStateMachine);
  // select autonomous mode
  if (vexRT[Btn7R]==1)
  		{
  		score_mode+=1;   // 1, Red: Front, 2 Blue: Front  3, Blue: Left, 4, Blue: Right
  		if (score_mode==5) score_mode=0; //remove overflow, only 1,2,3 value allowed
  		wait1Msec(500); //  to avoid sticky repeats
  		}
	if (vexRT[Btn7U]==1)
  		{
   		moveUpFront(50);
   		FrontHoldPower=10;
			}
			else if (vexRT[Btn7D]==1)
			{
			moveUpFront(-50);
			FrontHoldPower=0;

			}
			else moveUpFront(FrontHoldPower);

	if (vexRT[Btn6D]==1)
  		{
  		Btn6D_pressed=1;
  		//Roller_InPowerLevel*= -1;  // + In, - out
  		Roller_InPower=	Roller_InPowerLevel;
  		turnLEDOn(shotLED);
			}
			else     //6D ==0
			{
				if (Btn6D_pressed==1)  Roller_InPowerLevel*= -1;  // + in, - Out
				Btn6D_pressed=0;
			}

	if (vexRT[Btn6U]==1)
  		{
  		Btn6U_pressed=1;
  		Roller_UpPower=	Roller_UpPowerLevel;
  		if (Roller_UpPower==0)
  				{
  					Roller_InPower=0;
  					Roller_InPowerLevel	= Roller_InPowerLevelMax;
  					turnLEDOff(shotLED);
  				}
			}
			else     //6U ==0
			{
				if (Btn6U_pressed==1)
					{
						Roller_UpPowerLevel=Roller_UpPowerLevelMax-Roller_UpPower;
					}
				Btn6U_pressed=0;
			}

   forwards=vexRT[Ch3];//+forwardsFine*(vexRT[Btn8U]-vexRT[Btn8D]);
   turnClock=vexRT[Ch4]/2;
   if (fabs(turnClock)<20) turnClock=0;
		move3D(forwards,0,turnClock);
		moveRollers();
//		movePunch();
		DisplayData();
  }
}
void move3D(int forwardsPower,int right, int turnClockPower)
{
 //if (abs(turnClockPower)<20) turnClockPower=0;
 int power=forwardsPower-turnClockPower;
 motor[RightFrontMotor1] = power;
 motor[RightRearMotor10] = power;
 power=forwardsPower+turnClockPower;
 motor[LeftFrontMotor2A] = power;
 motor[LeftRearMotor9D] = power;
}

void moveForward(int forwardsPower, int turnClockPower)
{
 int power=forwardsPower-turnClockPower;
 motor[RightFrontMotor1] = power;
 motor[RightRearMotor10] = power;
 power=forwardsPower+turnClockPower;
 motor[LeftFrontMotor2A] = power;
 motor[LeftRearMotor9D] = power;
}

void moveForwardFront(int forwardPower, int turnClockPower)
{
 int power=forwardPower-turnClockPower;
 motor[RightFrontMotor1] = power;
 power=forwardPower+turnClockPower;
 motor[LeftFrontMotor2A] = power;
}
void moveForwardBack(int forwardPower, int turnClockPower)
{
 int power=forwardPower-turnClockPower;
 motor[RightRearMotor10] = power;
 power=forwardPower+turnClockPower;
 motor[LeftRearMotor9D] = power;
}

void moveUpFront(int FWpower)
{
motor[FrontWheelLift3BY]=FWpower;
}

void moveIntake(int istart)
{
	int power=50;
	if (abs(istart)>1)
		motor[Roller_In4]=istart;
	else
		motor[Roller_In4]=istart*power;
	touchsensor=istart*power+2;
}
void movePunch()
{
	motor[ShotMotor8Y]=PunchPower;  // controled by Punch State machine
}

void moveRollers()
{
	motor[Roller_In4]=Roller_InPower;
	motor[Roller_Up5]=Roller_UpPower;
	motor[Roller_Up6C]=Roller_UpPower;
}

void ShotBall()
{
	int power=100;
	motor[ShotMotor8Y]=power;		// run motor
	waitUntil(SensorValue(shotStop) == 0);
	waitUntil(SensorValue(shotStop) == 1);
//	motor[shotMotor8]=-power/4;// stop motor
//	wait10Msec(50); // wait for  0
	motor[ShotMotor8Y]=0;// stop motor
	touchsensor=SensorValue(shotStop);
}

void moveWall2SonarDistanceMM(float velocity, float sideDistance, float moveDistanceMM)
{
	  float headSonarValue,frontSonarValue,backSonarValue, sideFrontSonar, sideBackSonar;
    float diffFront, diffBack, moveDistance;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
    while(true)
    {
    headSonarValue = SensorValue[HeadSonic];
    frontSonarValue = SensorValue[FrontSonic];
    backSonarValue = SensorValue[BackSonic];
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=25.4*Lencode/Inches2encoder;
		rightTravel=25.4*Rencode/Inches2encoder;
		if (fabs(leftTravel)+fabs(rightTravel)>2*moveDistanceMM)	break;
    sideBackSonar=backSonarValue;
    sideFrontSonar=frontSonarValue;

    diffFront = (sideFrontSonar - sideDistance) ;
    diffBack = (sideBackSonar - sideDistance) ;
        int diff = 0.2*fabs(velocity)*sgn((sideFrontSonar - sideBackSonar))*colorfactor;
        int strafePower = colorfactor*0.2*abs(velocity)*sgn((sideDistance - (sideBackSonar + sideFrontSonar)/2));
 		moveForwardFront(velocity,-diff);
 		moveForwardBack(velocity, -diff-strafePower);
    }
    moveForward(0,0);
}
void moveForwardDistanceInch(float distance_Left, float distance_Right,int power)
{
	float left2right_ratio=distance_Left/distance_Right;
	move3D(power,0,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	while (true)
	{
//		Lencode=fabs(nMotorEncoder[leftMotor]);
//		Rencode=fabs(nMotorEncoder[rightMotor]);//*101/63;
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=leftTravel-rightTravel*left2right_ratio;
		if (fabs(leftTravel)>distance_Left)	break;
		if (fabs(rightTravel)>distance_Right)	break;
//		moveForward(power,-diff*power/fabs(power+0.001));
		moveForward(power,0);
	}
  move3D(0,0,0);
}
void moveTurnRightDegree(int turnDegree,int power)
{
	float turnDistance=3.14*turnDiameter*turnDegree/360;
	moveTurnRightDistanceInch(turnDistance, turnDistance,power);
}

void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power)
{
		moveForward(0,power);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */

  while (true)
	{

		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=abs(Lencode)-abs(Rencode);
		if (abs(leftTravel)>abs(distance_Left))	break;
		if (abs(rightTravel)>abs(distance_Right))	break;
//		moveForward(diff*power/fabs(power+0.001),power);
		moveForward(diff*power/fabs(power+0.001),power);
	}
  move3D(0,0,0);
}

void DisplayData()
{
//	score_mode=-1;
	if ((score_mode)>=0)  // <0 score mode shows data
	{
 		displayLCDString(0, 0, "Auto Selected: ");
		if (score_mode==0) displayLCDString(1, 0, "score: No Autonomus ");
		if (score_mode==1) displayLCDString(1, 0, "score: Red Front   ");
		if (score_mode==2) displayLCDString(1, 0, "score: Blue Front   ");
		if (score_mode==3) displayLCDString(1, 0, "score: Red Back    ");
		if (score_mode==4) displayLCDString(1, 0, "score: Blue Back ");
		return;
	}
	else{
		GyroTop=SensorValue[GyroTop8]*GyroBalance;
		GyroBot=SensorValue[GyroBot7];
		GyroAngle=(GyroTop-GyroBot)*Gyro_Cali;
 		displayLCDString(0, 0, "GT:");
 		displayNextLCDNumber(GyroTop);
 		displayNextLCDString(",GB:");
 		displayNextLCDNumber(GyroBot);
 //		displayNextLCDString(":Diff= ");

// 		displayLCDString(1,0,"Run Time:diff ");
 		displayLCDString(1,0,"HS");
		displayNextLCDNumber(SensorValue[HeadSonic]);
  		displayNextLCDString(" FS");
		displayNextLCDNumber(SensorValue[FrontSonic]);
  		displayNextLCDString(" BS");
 		displayNextLCDNumber(SensorValue[BackSonic]);
  		displayNextLCDString("  ");
		//displayNextLCDNumber(time1[T1]/10);
 		//displayNextLCDNumber(SensorValue(Potent));//[T1]/10);
 	}
}

void AUTO_Red_Front()
{
	colorfactor=1;
	moveWall2SonarDistanceMM(60,170, 200);
	PunchTriggerAuto=true;
	wait1Msec(3000);
	moveTurnRightDegree(10,-50)
	moveWall2SonarDistanceMM(60,120, 100);
	wait1Msec(200);
	moveWall2SonarDistanceMM(-60,120, 700);
	moveTurnRightDegree(90,-80)
	moveForwardDistanceInch(60,60,-100);
	return;
	}

void AUTO_Blue_Front()
	{
		colorfactor=-1;
	moveWall2SonarDistanceMM(60,170, 200);
	PunchTriggerAuto=true;
	wait1Msec(3000);
	moveTurnRightDegree(10,-50)
	moveWall2SonarDistanceMM(60,120, 100);
	wait1Msec(200);
	moveWall2SonarDistanceMM(-60,120, 700);
	moveTurnRightDegree(90,80)
	moveForwardDistanceInch(60,60,-100);
	return;
	}
void AUTO_Red_Back()
	{
	PunchTriggerAuto=true;
	wait1Msec(5000);
	moveTurnRightDegree(20,-60);
	moveForwardDistanceInch(16,16,50);
	wait1Msec(500);
	moveTurnRightDegree(90,60);
	wait1Msec(500);
	moveForwardDistanceInch(60,60,100);

return;

	}

void AUTO_Blue_Back()
	{
			PunchTriggerAuto=true;
	wait1Msec(5000);
	moveTurnRightDegree(20,60);
	moveForwardDistanceInch(16,16,50);
	wait1Msec(500);
	moveTurnRightDegree(90,-60);
	wait1Msec(500);
	moveForwardDistanceInch(60,60,100);

return;

	}

task PunchStateMachine()
	{
	 	// punch move								status
	 	//  A,					S=1, P=0, 	Init=0,  5D to power
		//	B,					S=1, p!=0  			1,  triggered S,start to engage
		// 	C, 					S=0, P!=0, 			2,  release S,
		//  D, (Delay)	S=0, P=P_hold, 	3, Hold engaged
		//	E,					S=0, p!=0, 			4,		5D to Fire
		//  when fired, goto B (1)
		//
		while(true)
		{
			PunchShotStop=SensorValue[shotStop];
			if (vexRT(Btn5D)==1) PunchTriggerred=true;
		switch (PunchState)
			{
				case 0: // intit, S=1, P=0
					if (PunchTriggerred||PunchTriggerAuto)
					{  // free stand punch
					PunchPower=PunchPowerMax;
					PunchState++; // if triggered, move on.
					}
					// stay in init position, if not triggered
					break;
				case 1: //s=1
					if (PunchTriggerred||PunchTriggerAuto)
							PunchPower=PunchPowerMax; // move to hold position
//					PunchTriggerAuto=false; //reset trigger
					if (PunchShotStop==0) PunchState++; //Power continue until S=0
					break;
				case	2:
					wait1Msec(1000);		//S=0
					PunchPower=PunchPowerHold;  //hold the punch, S=0
					PunchState++;
					break;
				case 3:
					if (PunchTriggerred||PunchTriggerAuto) // 5d or auto trigger
					{
					PunchPower=PunchPowerMax; //fire
					PunchTriggerAuto=false; //reset
					PunchTriggerred=false;
					}
					//else wait for shot
					if (PunchShotStop==1) PunchState=1; //return to 1
					break;
				default: break;
			}
			wait1Msec(10);
			movePunch();
	}
}
