#pragma config(Sensor, in1,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    PotHand,        sensorPotentiometer)
#pragma config(Sensor, in7,    GyroBot7,       sensorGyro)
#pragma config(Sensor, in8,    GyroTop8,       sensorGyro)
#pragma config(Sensor, dgtl1,  frontSonic,     sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  leftSonice,     sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  shotLED,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  shotStop,       sensorTouch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightSonic,     sensorSONAR_inch)
#pragma config(Motor,  port1,           RightFrontMotor1, tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           LeftFrontMotor2A, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           FrontWheelLift3BY, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           Roller_In4,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Roller_Up5,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Roller_Up6C,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           CapFliper7,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           ShotMotor8Y,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LeftRearMotor9D, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port10,          RightRearMotor10, tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

	int Inches2encoder=27;
	int turnDiameter=14;
	float leftTravel,rightTravel, diff;
	int Lencode,Rencode;
	int armLiftAngle;
 	float armCurrentAngle;
	float armTargetAngle;
	int handCloseAngle;
	int turnClock;
  int up;
  int armHoldLightPower=15;
	int touchsensor=2;
  int score_mode=3;//default ed back
	int timeDrop=0;
	int timeCount=0;
	int Roller_InPower=0;
	int Roller_InPowerLevelMax=100;
	int Roller_InPowerLevel=Roller_InPowerLevelMax;
	int Roller_UpPower=0;
	int Roller_UpPowerLevelMax=100;
	int Roller_UpPowerLevel=Roller_UpPowerLevelMax;
	int Btn6D_pressed=0;
	int Btn6U_pressed=0;
	int PunchState=0;  // S=1, P=0
	int PunchPower=0;
	int PunchPowerMax=30;
	int PunchPowerHold=5;
	bool PunchTriggerred=false;
	bool PunchTriggerAuto=false;
	int PunchShotStop=0;
	int GyroTop=0;
	int GyroBot=0;
	float GyroBalance=1.3;
	float Gyro_Cali=-0.5/1.10;
	int GyroAngle=0;

void move3D(int forwardsPower,int right, int turnClockPower);
void moveArm(int power);
void moveForward(int forwardsPower, int turnClockPower);
void moveForwardDistanceInch(float distance_Left, float distance_Right, int power);
void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power);
void moveTurnRightDegree(int turnDegree,int power);
void DisplayData();
void moveArmUpDegree(int upDegree, int armPower);
void moveArmDownDegree(int downDegree, int armPower);
void moveIntake(int istart);
void moveRollers();
void movePunch();
void ShotBall();
void go_auto();
void go_test();
void AUTO_Red_Front();
void AUTO_Blue_Front();
void AUTO_Red_Back();
void AUTO_Blue_Back();
task PunchStateMachine();
//void AUTO_score_BLUE_left();

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	//score_mode=3;
	go_auto();
}

void go_auto()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	clearTimer(T1);
//	score_mode=2;
		if (score_mode==1) AUTO_Red_Front();
		if (score_mode==2) AUTO_Blue_Front();
		if (score_mode==3) AUTO_Red_Back();
		if (score_mode==4) AUTO_Blue_Back();
		if (score_mode==0) return;
	timeDrop=time1[T1];
	return;
}

void go_test()
{
	//go straight line for 100 inches
 //moveForwardDistanceInch(80,80, 20);
 	// turn 180 degree
 moveTurnRightDegree(180,50);
 wait1Msec(500);
 moveTurnRightDegree(180,-50);
}



/*---------111111111111111------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
  clearLCDLine(0);                  	// Clear line 1 (0) of the LCD
  clearLCDLine(1);                  	// Clear line 2 (1) of the LCD
  bLCDBacklight = true;             	// Turn on LCD Backlight
	clearTimer(T1);
	int forwards;
	SensorType(GyroTop8) = sensorNone;
	SensorType(GyroBot7) = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[GyroTop8] =sensorGyro; // sensorGyro;
	SensorType[GyroBot7] =sensorGyro; // sensorGyro;
	SensorValue[GyroBot7]=0;
	SensorValue[GyroTop8]=0;
	wait1Msec(2000);
	startTask(PunchStateMachine);  // controls Puch powwer
//  score_mode=3;
//  go_auto();
//  go_test();
  //return;

  while (true)
  {
//		startTask(PunchStateMachine);
  // select autonomous mode
  if (vexRT[Btn7R]==1)
  		{
  		score_mode+=1;   // 1, Red: Front, 2 Blue: Front  3, Blue: Left, 4, Blue: Right
  		if (score_mode==5) score_mode=0; //remove overflow, only 1,2,3 value allowed
  		wait1Msec(500); //  to avoid sticky repeats
  		}
//	touchsensor=SensorValue(shotStop);
  if (vexRT[Btn7U]==1)
  		moveIntake(80);
		else if (vexRT[Btn7D]==1)
			moveIntake(-1);
  	else 	if  (vexRT[Btn7L]==1)
  		moveIntake(0); // stop

	if (vexRT[Btn6D]==1)
  		{
  		Btn6D_pressed=1;
  		//Roller_InPowerLevel*= -1;  // + In, - out
  		Roller_InPower=	Roller_InPowerLevel;
  		turnLEDOn(shotLED);
			}
			else     //6D ==0
			{
				if (Btn6D_pressed==1)  Roller_InPowerLevel*= -1;  // + in, - Out
				Btn6D_pressed=0;
			}

	if (vexRT[Btn6U]==1)
  		{
  		Btn6U_pressed=1;
  		Roller_UpPower=	Roller_UpPowerLevel;
  		if (Roller_UpPower==0)
  				{
  					Roller_InPower=0;
  					Roller_InPowerLevel	= Roller_InPowerLevelMax;
  					turnLEDOff(shotLED);
  				}
			}
			else     //6U ==0
			{
				if (Btn6U_pressed==1)
					{
						Roller_UpPowerLevel=Roller_UpPowerLevelMax-Roller_UpPower;
					}
				Btn6U_pressed=0;
			}

   forwards=vexRT[Ch3];//+forwardsFine*(vexRT[Btn8U]-vexRT[Btn8D]);
   turnClock=vexRT[Ch4]/2;
   if (fabs(turnClock)<20) turnClock=0;
		move3D(forwards,0,turnClock);
		moveRollers();
//		movePunch();
		DisplayData();
  }
}
void move3D(int forwardsPower,int right, int turnClockPower)
{
 //if (abs(turnClockPower)<20) turnClockPower=0;
 int power=forwardsPower-turnClockPower;
 motor[RightFrontMotor1] = power;
 motor[RightRearMotor10] = power;
 power=forwardsPower+turnClockPower;
 motor[LeftFrontMotor2A] = power;
 motor[LeftRearMotor9D] = power;
}

void moveForward(int forwardsPower, int turnClockPower)
{
 int power=forwardsPower-turnClockPower;
 motor[RightFrontMotor1] = power;
 motor[RightRearMotor10] = power;
 power=forwardsPower+turnClockPower;
 motor[LeftFrontMotor2A] = power;
 motor[LeftRearMotor9D] = power;
}

void moveArm(int power)
{
//motor[armsMotor7]=power;
}

void moveIntake(int istart)
{
	int power=50;
	if (abs(istart)>1)
		motor[Roller_In4]=istart;
	else
		motor[Roller_In4]=istart*power;
	touchsensor=istart*power+2;
}
void movePunch()
{
	motor[ShotMotor8Y]=PunchPower;  // controled by Punch State machine
}

void moveRollers()
{
	motor[Roller_In4]=Roller_InPower;
	motor[Roller_Up5]=Roller_UpPower;
	motor[Roller_Up6C]=Roller_UpPower;
}

void ShotBall()
{
	int power=100;
	motor[ShotMotor8Y]=power;		// run motor
	waitUntil(SensorValue(shotStop) == 0);
	waitUntil(SensorValue(shotStop) == 1);
//	motor[shotMotor8]=-power/4;// stop motor
//	wait10Msec(50); // wait for  0
	motor[ShotMotor8Y]=0;// stop motor
	touchsensor=SensorValue(shotStop);
}

void moveForwardDistanceInch(float distance_Left, float distance_Right,int power)
{
	float left2right_ratio=distance_Left/distance_Right;
	move3D(power,0,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	while (true)
	{
//		Lencode=fabs(nMotorEncoder[leftMotor]);
//		Rencode=fabs(nMotorEncoder[rightMotor]);//*101/63;
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=leftTravel-rightTravel*left2right_ratio;
		if (fabs(leftTravel)>distance_Left)	break;
		if (fabs(rightTravel)>distance_Right)	break;
//		moveForward(power,-diff*power/fabs(power+0.001));
		moveForward(power,0);
	}
  move3D(0,0,0);
}
void moveTurnRightDegree(int turnDegree,int power)
{
	float turnDistance=3.14*turnDiameter*turnDegree/360;
	moveTurnRightDistanceInch(turnDistance, turnDistance,power);
}

void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power)
{
		moveForward(0,power);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */

  while (true)
	{

		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=abs(Lencode)-abs(Rencode);
		if (abs(leftTravel)>abs(distance_Left))	break;
		if (abs(rightTravel)>abs(distance_Right))	break;
//		moveForward(diff*power/fabs(power+0.001),power);
		moveForward(diff*power/fabs(power+0.001),power);
	}
  move3D(0,0,0);
}

void DisplayData()
{
	score_mode=-1;
	if ((score_mode)>=0)  // <0 score mode shows data
	{
 		displayLCDString(0, 0, "Auto Selected: ");
		if (score_mode==0) displayLCDString(1, 0, "score: No Autonomus ");
		if (score_mode==1) displayLCDString(1, 0, "score: Red Front   ");
		if (score_mode==2) displayLCDString(1, 0, "score: Blue Front   ");
		if (score_mode==3) displayLCDString(1, 0, "score: Red Back    ");
		if (score_mode==4) displayLCDString(1, 0, "score: Blue Back ");
		return;
	}
	else{
		GyroTop=SensorValue[GyroTop8]*GyroBalance;
		GyroBot=SensorValue[GyroBot7];
		GyroAngle=(GyroTop-GyroBot)*Gyro_Cali;
 		displayLCDString(0, 0, "GT:");
 		displayNextLCDNumber(GyroTop);
 		displayNextLCDString(",GB:");
 		displayNextLCDNumber(GyroBot);
 //		displayNextLCDString(":Diff= ");

// 		displayLCDString(1,0,"Run Time:diff ");
 		displayLCDString(1,0,"diff ");
		displayNextLCDNumber(GyroAngle);
  		displayNextLCDString("  ");
		//displayNextLCDNumber(time1[T1]/10);
 		//displayNextLCDNumber(SensorValue(Potent));//[T1]/10);
 	}
}

void moveArmUpDegree(int upDegree, int armPower)
{
	//get current armAngle
//		armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
		armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;

		armTargetAngle=armCurrentAngle+upDegree;
		moveArm(abs(armPower));
		while (true)
		{
//				armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
				armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;
				if (armCurrentAngle>armTargetAngle) break;
				if (armCurrentAngle>160) break;
				if (fabs(vexRT[Ch1])>30) break;
				if (fabs(vexRT[Ch2])>30) break;
		}
		moveArm(armHoldLightPower);
}

void moveArmDownDegree(int downDegree, int armPower)
{
	//get current armAngle
	//	armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
		armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;
		armTargetAngle=armCurrentAngle-downDegree;
		moveArm(-abs(armPower));
		while (true)
		{
				//armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
				armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;
				if (armCurrentAngle<armTargetAngle) break;
				if (armCurrentAngle<20) break;
		}
		moveArm(armHoldLightPower);
}

void AUTO_Red_Front()
{
			moveArmUpDegree(60, 100);
		moveForwardDistanceInch(49,49,100);
		moveArmDownDegree(55, 20);
	  moveArmDownDegree(5, 50);
	  moveArm(-30);
 //	  wait1Msec(200);
		moveForwardDistanceInch(5,5,-50);
		moveArmUpDegree(60, 100);
 	return;
	}

void AUTO_Blue_Front()
	{
		moveArmUpDegree(60, 100);
		moveForwardDistanceInch(49,49,100);
		moveArmDownDegree(55, 20);
	  moveArmDownDegree(5, 50);
	  moveArm(-30);
 //	  wait1Msec(200);
		moveForwardDistanceInch(0.5,0.5,-50);
 		moveArmUpDegree(25, 100);
//		moveHandsHold(120, 40);
	  wait1Msec(200);
		moveForwardDistanceInch(12,12,-80);
		moveForwardDistanceInch(35,28,-80);
		moveForwardDistanceInch(45,30,-80);
		moveForwardDistanceInch(17,17,-80);
 		moveTurnRightDegree(90,-50);
		moveForwardDistanceInch(20,20,100);
	  moveArmDownDegree(10, 50);
//    moveHandSetDegree(130,50);
    timeDrop=time1[T1];
    wait1Msec(200);
		moveForwardDistanceInch(15,15,-100);
		moveTurnRightDegree(90,100);
    timeCount=time1[T1];
return;
}
void AUTO_Red_Back()
	{
		moveIntake(-80);
		up=10;
		moveForwardDistanceInch(30,30,60);
		up=15;
		moveForwardDistanceInch(10,10,30);
		up=20;
		wait1Msec(200);
		moveIntake(0);
		moveTurnRightDegree(15,-50);
		up=25;
		moveForwardDistanceInch(15,15,-30);
		up=30;
		moveArm(-100);
		wait1Msec(500);
		moveArm(0);
//		moveIntake(100);
		moveTurnRightDegree(60,50);
		moveForwardDistanceInch(9,9,50);
		moveArm(100);
		wait1Msec(500);
		moveArm(-80);
//		moveForwardDistanceInch(5,5,-50);
//		moveTurnRightDegree(30,-50);
//		moveForwardDistanceInch(50,50,-50);
//		moveTurnRightDegree(145,50);
		wait1Msec(400);
	//	moveForwardDistanceInch(50,50,-100);
    timeCount=time1[T1];
return;

	}

void AUTO_Blue_Back()
	{
				moveIntake(-80);
		up=10;
		moveForwardDistanceInch(30,30,60);
		up=15;
		moveForwardDistanceInch(10,10,30);
		up=20;
		wait1Msec(200);
		moveIntake(0);
		moveTurnRightDegree(15,50);
		up=25;
		moveForwardDistanceInch(15,15,-30);
		up=30;
		moveArm(-100);
		wait1Msec(500);
		moveArm(0);
//		moveIntake(100);
		moveTurnRightDegree(60,-50);
		moveForwardDistanceInch(9,9,50);
		moveArm(100);
		moveForwardDistanceInch(1,1,50);
		wait1Msec(500);
		moveArm(-80);
//		moveForwardDistanceInch(5,5,-50);
//		moveTurnRightDegree(30,-50);
//		moveForwardDistanceInch(50,50,-50);
//		moveTurnRightDegree(145,-50);
		wait1Msec(400);
//		moveForwardDistanceInch(50,50,-100);
    timeCount=time1[T1];
return;

	}

task PunchStateMachine()
	{
	 	// punch move								status
	 	//  A,					S=1, P=0, 	Init=0,  5D to power
		//	B,					S=1, p!=0  			1,  triggered S,start to engage
		// 	C, 					S=0, P!=0, 			2,  release S,
		//  D, (Delay)	S=0, P=P_hold, 	3, Hold engaged
		//	E,					S=0, p!=0, 			4,		5D to Fire
		//  when fired, goto B (1)
		//
		while(true)
		{
			PunchShotStop=SensorValue[shotStop];
			if (vexRT(Btn5D)==1) PunchTriggerred=true;
		switch (PunchState)
			{
				case 0: // intit, S=1, P=0
					if (PunchTriggerred||PunchTriggerAuto)
					{  // free stand punch
					PunchPower=PunchPowerMax;
					PunchState++; // if triggered, move on.
					}
					// stay in init position, if not triggered
					break;
				case 1: //s=1
					if (PunchTriggerred||PunchTriggerAuto)
							PunchPower=PunchPowerMax; // move to hold position
//					PunchTriggerAuto=false; //reset trigger
					if (PunchShotStop==0) PunchState++; //Power continue until S=0
					break;
				case	2:
					wait1Msec(3000);		//S=0
					PunchPower=PunchPowerHold;  //hold the punch, S=0
					PunchState++;
					break;
				case 3:
					if (PunchTriggerred||PunchTriggerAuto) // 5d or auto trigger
					{
					PunchPower=PunchPowerMax; //fire
					PunchTriggerAuto=false; //reset
					PunchTriggerred=false;
					}
					//else wait for shot
					if (PunchShotStop==1) PunchState=1; //return to 1
					break;
				default: break;
			}
			wait1Msec(10);
			movePunch();
	}
}
