#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in2,    PotHand,        sensorPotentiometer)
#pragma config(Sensor, in8,    PotArm,         sensorNone)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  ,               sensorTouch)
#pragma config(Sensor, dgtl10, ,               sensorTouch)
#pragma config(Sensor, dgtl12, shotStop,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop, reversed, driveRight)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port3,           intakeMotor3,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,            ,             tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,            ,             tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armsMotor7,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           shotMotor8,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port10,           ,             tmotorVex393_HBridge, openLoop, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

	int Inches2encoder=27;
	int turnDiameter=14;
	float leftTravel,rightTravel, diff;
	int Lencode,Rencode;
	int armLiftAngle;
 	float armCurrentAngle;
	float armTargetAngle;
	int handCloseAngle;
	int turnClock;
  int turnClockFine=20;
  int up;
  int armHoldLightPower=15;
  int armPower=0;
  int armHoldPower=armHoldLightPower;
	int touchsensor=2;
  int score_mode=3;//default ed back
	int timeDrop=0;
	int timeCount=0;

void move3D(int forwardsPower,int right, int turnClockPower);
void moveArm(int power);
void moveForward(int forwardsPower, int turnClockPower);
void moveForwardDistanceInch(float distance_Left, float distance_Right, int power);
void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power);
void moveTurnRightDegree(int turnDegree,int power);
void DisplayData();
void moveArmUpDegree(int upDegree, int armPower);
void moveArmDownDegree(int downDegree, int armPower);
void moveIntake(int istart);
void ShotBall();
void go_auto();
void go_test();
void AUTO_Red_Front();
void AUTO_Blue_Front();
void AUTO_Red_Back();
void AUTO_Blue_Back();
//void AUTO_score_BLUE_left();

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	//score_mode=3;
	go_auto();
}

void go_auto()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  clearLCDLine(0);                      // Clear line 1 (0) of the LCD
  clearLCDLine(1);                      // Clear line 2 (1) of the LCD
  bLCDBacklight = true;                 // Turn on LCD Backlight
	clearTimer(T1);
//	score_mode=2;
		if (score_mode==1) AUTO_Red_Front();
		if (score_mode==2) AUTO_Blue_Front();
		if (score_mode==3) AUTO_Red_Back();
		if (score_mode==4) AUTO_Blue_Back();
		if (score_mode==0) return;
	timeDrop=time1[T1];
	return;
}

void go_test()
{
	//go straight line for 100 inches
 //moveForwardDistanceInch(80,80, 20);
 	// turn 180 degree
 moveTurnRightDegree(180,50);
 wait1Msec(500);
 moveTurnRightDegree(180,-50);
}

/*---------111111111111111------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  // User control code here, inside the loop
  clearLCDLine(0);                  	// Clear line 1 (0) of the LCD
  clearLCDLine(1);                  	// Clear line 2 (1) of the LCD
  bLCDBacklight = true;             	// Turn on LCD Backlight
	clearTimer(T1);
	int forwards;
	int forwardsFine=20;
  int right;

//  score_mode=3;
//  go_auto();
//  go_test();
  //return;

  while (true)
  {
  // select autonomous mode
  if (vexRT[Btn7R]==1)
  		{
  		score_mode+=1;   // 1, Red: Front, 2 Blue: Front  3, Blue: Left, 4, Blue: Right
  		if (score_mode==5) score_mode=0; //remove overflow, only 1,2,3 value allowed
  		wait1Msec(500); //  to avoid sticky repeats
  		}
//	touchsensor=SensorValue(shotStop);
  if (vexRT[Btn7U]==1)
  		moveIntake(80);
		else if (vexRT[Btn7D]==1)
			moveIntake(-1);
  	else 	if  (vexRT[Btn7L]==1)
  		moveIntake(0); // stop

	if (vexRT[Btn6D]==1)
  		{
				ShotBall();
		}

   forwards=vexRT[Ch2]+forwardsFine*(vexRT[Btn8U]-vexRT[Btn8D]);
   right=0;
   up=0;
//	 turnClock=0;
    turnClock=vexRT[Ch1]/2;
    if (fabs(turnClock)<20) turnClock=0;
    turnClock += turnClockFine*(vexRT[Btn8R]-vexRT[Btn8L]);
		//switch holding power depend on load
   	up=vexRT[Ch3];
    armPower=up+armHoldPower;
		moveArm(armPower);
		move3D(forwards,0,turnClock);
	//	armLiftAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
		DisplayData();
  }
}
void move3D(int forwardsPower,int right, int turnClockPower)
{
 //if (abs(turnClockPower)<20) turnClockPower=0;
 int power=forwardsPower-turnClockPower;
 motor[rightMotor] = power;
 power=forwardsPower+turnClockPower;
 motor[leftMotor] = power;
}

void moveForward(int forwardsPower, int turnClockPower)
{
 int power=forwardsPower-turnClockPower;
 motor[rightMotor] = power;
 power=forwardsPower+turnClockPower;
 motor[leftMotor] = power;
}

void moveArm(int power)
{
motor[armsMotor7]=power;
}

void moveIntake(int istart)
{
	int power=50;
	if (abs(istart)>1)
		motor[intakeMotor3]=istart;
	else
		motor[intakeMotor3]=istart*power;
	touchsensor=istart*power+2;
}

void ShotBall()
{
	int power=100;
	motor[shotMotor8]=power;		// run motor
	waitUntil(SensorValue(shotStop) == 0);
	waitUntil(SensorValue(shotStop) == 1);
//	motor[shotMotor8]=-power/4;// stop motor
//	wait10Msec(50); // wait for  0
	motor[shotMotor8]=0;// stop motor
	touchsensor=SensorValue(shotStop);
}

void moveForwardDistanceInch(float distance_Left, float distance_Right,int power)
{
	float left2right_ratio=distance_Left/distance_Right;
	move3D(power,0,0);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */
	while (true)
	{
//		Lencode=fabs(nMotorEncoder[leftMotor]);
//		Rencode=fabs(nMotorEncoder[rightMotor]);//*101/63;
		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=leftTravel-rightTravel*left2right_ratio;
		if (fabs(leftTravel)>distance_Left)	break;
		if (fabs(rightTravel)>distance_Right)	break;
//		moveForward(power,-diff*power/fabs(power+0.001));
		moveForward(power,0);
	}
  move3D(0,0,0);
}
void moveTurnRightDegree(int turnDegree,int power)
{
	float turnDistance=3.14*turnDiameter*turnDegree/360;
	moveTurnRightDistanceInch(turnDistance, turnDistance,power);
}

void moveTurnRightDistanceInch(float distance_Left, float distance_Right,int power)
{
		moveForward(0,power);
	//wait for travel distance of Inch, then Stop
// 	nMotorEncoder[leftMotor]=0;
// 	nMotorEncoder[rightMotor]=0;
  SensorValue[rightEncoder] = 0;    /* Clear the encoders for    */
  SensorValue[leftEncoder] = 0;    /* Clear the encoders for    */

  while (true)
	{

		Lencode=fabs(SensorValue[leftEncoder]);
		Rencode=fabs(SensorValue[rightEncoder]);
		leftTravel=Lencode/Inches2encoder;
		rightTravel=Rencode/Inches2encoder;
		diff=abs(Lencode)-abs(Rencode);
		if (abs(leftTravel)>abs(distance_Left))	break;
		if (abs(rightTravel)>abs(distance_Right))	break;
//		moveForward(diff*power/fabs(power+0.001),power);
		moveForward(diff*power/fabs(power+0.001),power);
	}
  move3D(0,0,0);
}

void DisplayData()
{
	if ((score_mode)>=0)  // <0 score mode shows data
	{
 		displayLCDString(0, 0, "Auto Selected: ");
		if (score_mode==0) displayLCDString(1, 0, "score: No Autonomus ");
		if (score_mode==1) displayLCDString(1, 0, "score: Red Front   ");
		if (score_mode==2) displayLCDString(1, 0, "score: Blue Front   ");
		if (score_mode==3) displayLCDString(1, 0, "score: Red Back    ");
		if (score_mode==4) displayLCDString(1, 0, "score: Blue Back ");
		return;
	}
	else{
		armLiftAngle=32+58*(SensorValue(Potent)-1590)/960;
 		displayLCDString(0, 0, "Arm:");
 		displayNextLCDNumber(armLiftAngle);
 		displayNextLCDString(",Hand:");
 		displayNextLCDNumber(handCloseAngle);
 		displayNextLCDString("  ");
 		displayLCDString(1,0,"Run Time: ");
 		//displayNextLCDNumber(time1[T1]/10);
 		displayNextLCDNumber(SensorValue(Potent));//[T1]/10);
 	}
}

void moveArmUpDegree(int upDegree, int armPower)
{
	//get current armAngle
//		armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
		armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;

		armTargetAngle=armCurrentAngle+upDegree;
		moveArm(abs(armPower));
		while (true)
		{
//				armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
				armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;
				if (armCurrentAngle>armTargetAngle) break;
				if (armCurrentAngle>160) break;
				if (fabs(vexRT[Ch1])>30) break;
				if (fabs(vexRT[Ch2])>30) break;
		}
		moveArm(armHoldLightPower);
}

void moveArmDownDegree(int downDegree, int armPower)
{
	//get current armAngle
	//	armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
		armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;
		armTargetAngle=armCurrentAngle-downDegree;
		moveArm(-abs(armPower));
		while (true)
		{
				//armCurrentAngle=nMotorEncoder[armsMotor5]/armAngleScale+90-1220/armAngleScale;
				armCurrentAngle=32+58*(SensorValue(Potent)-1590)/960;
				if (armCurrentAngle<armTargetAngle) break;
				if (armCurrentAngle<20) break;
		}
		moveArm(armHoldLightPower);
}

void AUTO_Red_Front()
{
			moveArmUpDegree(60, 100);
		moveForwardDistanceInch(49,49,100);
		moveArmDownDegree(55, 20);
	  moveArmDownDegree(5, 50);
	  moveArm(-30);
 //	  wait1Msec(200);
		moveForwardDistanceInch(5,5,-50);
		moveArmUpDegree(60, 100);
 	return;
	}

void AUTO_Blue_Front()
	{
		moveArmUpDegree(60, 100);
		moveForwardDistanceInch(49,49,100);
		moveArmDownDegree(55, 20);
	  moveArmDownDegree(5, 50);
	  moveArm(-30);
 //	  wait1Msec(200);
		moveForwardDistanceInch(0.5,0.5,-50);
 		moveArmUpDegree(25, 100);
//		moveHandsHold(120, 40);
	  wait1Msec(200);
		moveForwardDistanceInch(12,12,-80);
		moveForwardDistanceInch(35,28,-80);
		moveForwardDistanceInch(45,30,-80);
		moveForwardDistanceInch(17,17,-80);
 		moveTurnRightDegree(90,-50);
		moveForwardDistanceInch(20,20,100);
	  moveArmDownDegree(10, 50);
//    moveHandSetDegree(130,50);
    timeDrop=time1[T1];
    wait1Msec(200);
		moveForwardDistanceInch(15,15,-100);
		moveTurnRightDegree(90,100);
    timeCount=time1[T1];
return;
}
void AUTO_Red_Back()
	{
		moveIntake(-80);
		up=10;
		moveForwardDistanceInch(30,30,60);
		up=15;
		moveForwardDistanceInch(10,10,30);
		up=20;
		wait1Msec(200);
		moveIntake(0);
		moveTurnRightDegree(15,-50);
		up=25;
		moveForwardDistanceInch(15,15,-30);
		up=30;
		moveArm(-100);
		wait1Msec(500);
		moveArm(0);
//		moveIntake(100);
		moveTurnRightDegree(60,50);
		moveForwardDistanceInch(9,9,50);
		moveArm(100);
		wait1Msec(500);
		moveArm(-80);
//		moveForwardDistanceInch(5,5,-50);
//		moveTurnRightDegree(30,-50);
//		moveForwardDistanceInch(50,50,-50);
//		moveTurnRightDegree(145,50);
		wait1Msec(400);
	//	moveForwardDistanceInch(50,50,-100);
    timeCount=time1[T1];
return;

	}

void AUTO_Blue_Back()
	{
				moveIntake(-80);
		up=10;
		moveForwardDistanceInch(30,30,60);
		up=15;
		moveForwardDistanceInch(10,10,30);
		up=20;
		wait1Msec(200);
		moveIntake(0);
		moveTurnRightDegree(15,50);
		up=25;
		moveForwardDistanceInch(15,15,-30);
		up=30;
		moveArm(-100);
		wait1Msec(500);
		moveArm(0);
//		moveIntake(100);
		moveTurnRightDegree(60,-50);
		moveForwardDistanceInch(9,9,50);
		moveArm(100);
		moveForwardDistanceInch(1,1,50);
		wait1Msec(500);
		moveArm(-80);
//		moveForwardDistanceInch(5,5,-50);
//		moveTurnRightDegree(30,-50);
//		moveForwardDistanceInch(50,50,-50);
//		moveTurnRightDegree(145,-50);
		wait1Msec(400);
//		moveForwardDistanceInch(50,50,-100);
    timeCount=time1[T1];
return;

	}
